<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。 SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）： cache 
	– 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 描述如何从数据库结果集中来加载对象。 
	parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。 sql – 可被其他语句引用的可重用语句块。 
	insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 -->
<mapper namespace="com.luoyunfan.dao.IStudentDao">
	<!--配置查询结果集和对象的映射，可以不进行配置，默认属性名和列名相同 -->
	<!-- javaType 一个 Java 类的完全限定名,或一个类型别名 jdbcType JDBC类型, 仅需要对插入,更新可能为空的列进行处理 -->
	<!-- 配置student表映射 -->
	<resultMap id="studentMap" type="com.luoyunfan.entity.Student">
	 
		<id column="stu_zh" property="stuZh" jdbcType="VARCHAR" />
		<result column="stu_pwd" property="stuPwd" jdbcType="VARCHAR" />
		<result column="stu_Name" property="stuName" jdbcType="VARCHAR" />
		<result column="stu_Phone" property="stuPhone" jdbcType="VARCHAR" />
	</resultMap>
 	<select id="findOne" resultMap="studentMap">
 		select * from student where stu_zh = #{stuZh}
 	</select>
 	<insert id="registStu"><!--  useGeneratedKeys="true" keyProperty="stuID" -->
		<selectKey keyProperty="stuZh" order="AFTER" resultType="java.lang.String">
			SELECT LAST_INSERT_ID()
		</selectKey>
		insert into student (stu_zh,stu_pwd,stu_name,stu_phone)
		values(#{stuZh},#{stuPwd},#{stuName},#{stuPhone})
	</insert>
	<!-- 查询所有学生 -->
	<select id="stuSearchAll" resultMap="studentMap">
		select * from student
	</select>
	<!-- 按条件查询学生 -->
	<select id="searchByCondition" resultMap="studentMap">
        select * from student t1
        <where>
            <if test="stuZh!=null">
                t1.stu_zh=#{stuZh}
            </if>

            <if test="stuName!=null">
                and t1.stu_Name=#{stuName}
            </if>
        </where>
    </select>
    <!-- 删除学生 -->	
    <delete id="delStu">
		delete from student where stu_zh = #{stuZh}
	</delete>
	
	
	<update id="updateInfo">
		update student set
			stu_Phone = #{stuPhone},
			stu_pwd =#{stuPwd}
			where stu_zh = #{stuZh}
	</update>
	
	
	
	
	
	
	
	<!-- 配置一对一关联映射 student_info和student -->
	<!-- <resultMap id="stuAndstuInfo" type="com.luoyunfan.entity.Student"> -->
		 
		<!--<id column="stu_zh" property="stuZh" jdbcType="VARCHAR" />
		<result column="stu_pwd" property="stuPwd" jdbcType="VARCHAR" />
		<association property="studentInfo" javaType="com.luoyunfan.entity.StudentInfo"
			select="selectStuInfo" column="stu_id" fetchType="lazy"></association>
	</resultMap> -->
	<!-- 一对多 -->
	<!-- <resultMap type="com.luoyunfan.entity.Student" id="stuAndRoles">
		<id column="stu_id" property="stuID" jdbcType="VARCHAR" />
		<result column="stu_zh" property="stuZh" jdbcType="VARCHAR" />
		<result column="stu_pwd" property="stuPwd" jdbcType="VARCHAR" />
		数据来自于下面select多表查询
		<collection property="roles" ofType="com.luoyunfan.entity.Role">
			<id column="role_id" property="roleID"></id>
			<result column="role_name" property="roleName"></result>
		</collection>


	</resultMap> -->

	<!-- 一对多 -->
	<!-- <select id="selectStuAndRoles" resultMap="stuAndRoles">
		SELECT * FROM student
		t1 LEFT JOIN role_stu t2 ON t1.stu_id = t2.stu_id LEFT JOIN role t3 ON
		t2.role_id = t3.role_id
	</select> -->


 



	<!-- <select id="selectPerson" 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType="int" 
		将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过调用方法的参数推断出参数的类型，从而在设置sql的参数时，根据参数类型选择对应的typeHandler，默认值为 
		unset。 resultType="hashmap" 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 
		resultType 或 resultMap，但不能同时使用。 resultMap="personResultMap" 外部 resultMap 
		的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 
		resultType，但不能同时使用。 flushCache="false" 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 
		useCache="true" 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout="10000" 
		这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize="256" 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 
		unset（依赖驱动）。 statementType="PREPARED" STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 
		MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 
		resultSetType="FORWARD_ONLY" FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 
		中的一个，默认值为 unset （依赖驱动）。 databaseId="oracle" 如果配置了 databaseIdProvider，MyBatis 
		会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 
		这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 
		resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。 > -->
	<!-- <select id="selectAllStu" resultMap="studentMap">
		select * from student
	</select>

	<select id="selectStuById" resultMap="studentMap">
		select * from student where
		stu_id = #{id}
	</select>


	动态sql
	<select id="findByContition" resultMap="studentMap">
		select * from student t1
		<where>
			<choose>
				<when test="stuID!=null">
					t1.stu_id=#{stuID}
				</when>
				 
				<when test="stuZh!=null">
				    t1.stu_zh =#{stuZh}
				</when>
				 <when test="stuPwd!=null">
				 	t1.stu_pwd=#{stuPwd}
				 </when>
			</choose>
		</where>
	</select> -->
	<!-- <select id="findById" resultMap="stuAndRoles">
			select * from student t1
			<where>
				<foreach collection="list" item="id" separator="or">
					t1.stu_id=#{id}
				</foreach>
			</where>
	</select> -->
	<!-- <insert id="insertAuthor" parameterType="domain.blog.Author" flushCache="true" 
		其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true statementType="PREPARED" keyProperty="" 
		（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 
		语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn="" 
		（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 
		useGeneratedKeys="" （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 
		方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 
		timeout="20" databaseId="oracle" 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 
		databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 > -->
	<!-- <selectKey keyProperty="id" selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 
		resultType="int" 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 
		Object 或一个 Map。 order="BEFORE" 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 
		keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 
		keyColumn="id" 匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 statementType="PREPARED" 
		与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 
		和 CallableStatement 类型。 > -->

	<!-- 

	<update id="updateStu">
		update student set
		stu_zh = #{stuZh},
		stu_pwd =
		#{stuPwd},

		where stu_id = #{stuID}
	</update>

	<delete id="deleteStu">
		delete from student where stu_id = #{id}
	</delete> -->


	<!-- 这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化 -->
	<!-- <sql id="studentColumns"></sql> -->

	<!-- 参数（Parameters） -->

	<!-- BaseTypeHandler中在insert或者update时，对于null值需要调用ps.setNull(i, JdbcType.OTHER.TYPE_CODE)方法， 
		该方法需要确认参数的类型，如果参数是通过Map传入的，则无法根据参数类型来确定 {middleInitial, mode=OUT, jdbcType=STRUCT, 
		jdbcTypeName=MY_TYPE, resultMap=departmentResultMap} -->

	<!-- 字符串替换 -->

	<!-- Result Maps constructor - 类在实例化时,用来注入结果到构造方法中 idArg - ID 参数;标记结果作为 
		ID 可以帮助提高整体效能 arg - 注入到构造方法的一个普通结果 id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能 result 
		– 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂的类型关联;许多结果将包成这种类型 嵌入结果映射 – 结果映射自身的关联,或者参考一个 
		collection – 复杂类型的集 嵌入结果映射 – 结果映射自身的集,或者参考一个 discriminator – 使用结果值来决定使用哪个结果映射 
		case – 基于某些值的结果映射 嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 -->
	 
</mapper>